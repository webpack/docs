<!DOCTYPE html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=description content=""><meta name=author content=""><link rel=icon type=image/png href=/assets/favicon.png><link rel=stylesheet href=css/doc.css><title>hot module replacement</title><body><script src=js/doc.js charset=utf-8 async></script><div class=container><div class=row><div class="col-md-3 nav"><div class=logo><ul class=cube-inner><li class=front></li><li class=back></li><li class=right></li><li class=left></li><li class=top></li><li class=bottom></li></ul><ul class=cube><li class=front></li><li class=back></li><li class=right></li><li class=left></li><li class=top></li><li class=bottom></li><li class=floor></li></ul></div><div class=name>webpack</div><div class=tagline>MODULE BUNDLER</div><div class=sidebar><ul><li><a href=.>Home</a></li></ul><ul><li>Getting Started<ul><li><a href=motivation.html>Motivation</a></li><li><a href=what-is-webpack.html>What is webpack?</a></li><li><a href=installation.html>Installation</a></li><li><a href=usage.html>Usage</a></li><li>Require Modules</li><li>Vendor Modules</li><li><a href=using-loaders.html>Using Loaders</a></li><li><a href=using-plugins.html>Using Plugins</a></li><li><a href=dev-tools.html>Dev Tools</a></li></ul></li><li>tutorials and examples<ul><li><a href="http://webpack.github.io/docs/tutorials/getting-started/">Getting started</a></li><li><a href=list-of-tutorials.html>List of tutorials</a></li><li><a href=examples.html>examples</a></li></ul></li><li>Guides<ul><li><a href=commonjs.html>CommonJs</a></li><li><a href=amd.html>AMD</a></li><li><a href=webpack-for-browserify-users.html>webpack for browserify users</a></li><li><a href=code-splitting.html>Code Splitting</a></li><li><a href=stylesheets.html>Stylesheets</a></li><li><a href=optimization.html>Optimization</a></li><li><a href=long-term-caching.html>Long-term Caching</a></li><li><a href=how-to-write-a-loader.html>How to write a loader</a></li><li>How to write a plugin</li><li><a href=multiple-entry-points.html>Multiple entry points</a></li><li><a href=library-and-externals.html>Library and externals</a></li><li><a href=shimming-modules.html>Shimming modules</a></li><li><a href=testing.html>Testing</a></li><li><a href=build-performance.html>Build performance</a></li><li><a href=hot-module-replacement-with-webpack.html>Hot Module Replacement with webpack</a></li><li><a href=comparison.html>Comparison</a></li></ul></li><li>Lists<ul><li><a href=list-of-loaders.html>List of loaders</a></li><li><a href=list-of-plugins.html>List of plugins</a></li></ul></li><li>webpack with<ul><li><a href=usage-with-grunt.html>grunt</a></li><li><a href=usage-with-gulp.html>gulp</a></li><li><a href=usage-with-bower.html>bower</a></li><li><a href=usage-with-karma.html>karma</a></li></ul></li><li>API<ul><li><a href=configuration.html>Configuration</a></li><li><a href=cli.html>CLI</a></li><li><a href=node.js-api.html>Node.js API</a></li><li><a href=api-in-modules.html>API in modules</a></li><li><a href=loaders.html>Loaders</a></li><li><a href=plugins.html>Plugins</a></li><li><a href=context.html>Context</a></li><li><a href=resolving.html>Resolving</a></li><li><a href=hot-module-replacement.html>Hot Module Replacement</a></li><li>Dev Tools<ul><li><a href=webpack-dev-server.html>webpack-dev-server</a></li><li><a href=webpack-dev-middleware.html>webpack-dev-middleware</a></li></ul></li></ul></li><li>Development<ul><li><a href=changelog.html>Changelog</a></li><li><a href=roadmap.html>Roadmap</a></li><li><a href=ideas.html>Ideas</a></li><li>Contributing</li></ul></li></ul></div></div><div class=col-md-9><div class=announcement><div class=announcement-inner><em>2014-07-04</em> Help to improve webpack by filling out <a href=https://docs.google.com/forms/d/101ZcujnVL8l575T6VRl62SfrVj5FZC1IzwMH1258GVc/viewform>this little survey</a>. Thanks!</div></div><div class=pull-right><a href=https://github.com/webpack/docs/wiki/hot-module-replacement/_edit id=wikieditlink>Edit</a></div><div class=row><div class="col-md-12 page-header"><h1 id=wikititle>hot module replacement</h1></div></div><div class=row><div id=wiki class=col-md-12><div class=contents><ul><li><a href=#examples>Examples</a></li><li><a href=#api>API</a><ul><li><a href=#accept><code>accept</code></a></li><li><a href=#decline><code>decline</code></a></li><li><a href=#dispose-adddisposehandler><code>dispose/addDisposeHandler</code></a></li><li><a href=#removedisposehandler><code>removeDisposeHandler</code></a></li></ul></li><li><a href=#management-api>Management API</a><ul><li><a href=#setapplyonupdate><code>setApplyOnUpdate</code></a></li><li><a href=#check><code>check</code></a></li><li><a href=#apply><code>apply</code></a></li><li><a href=#status><code>status</code></a></li><li><a href=#status-addstatushandler><code>status/addStatusHandler</code></a></li><li><a href=#removestatushandler><code>removeStatusHandler</code></a></li></ul></li><li><a href=#how-to-care-with>How to care with …</a></li></ul></div><p>“Hot Module Replacement” (HMR) is a feature to inject updated modules into the active runtime.</p><blockquote><p>It’s like LiveReload for every module.</p></blockquote><p>HMR is “opt-in”, so you need to put some code at chosen points of your application. The dependencies are handled by the module system.</p><p>I. e. you place your hot replacement code in module A. Module A requires module B and B requires C. If module C is updated, and module B cannot handle the update, modules B and C become outdated. Module A can handle the update and new modules B and C are injected.</p><h2 id=examples><a class=anchor href=#examples>&rarr;</a>Examples</h2><h4 id=example-1-hot-replace-request-handler-of-http-server><a class=anchor href=#example-1-hot-replace-request-handler-of-http-server>&rarr;</a>Example 1: hot replace request handler of http server</h4><pre><code><span class=keyword>var</span> requestHandler = require(<span class=string>"./handler.js"</span>);
<span class=keyword>var</span> server = require(<span class=string>"http"</span>).createServer();
server.on(<span class=string>"request"</span>, requestHandler);
server.listen(<span class=number>8080</span>);

<span class=comment>// check if HMR is enabled</span>
<span class=keyword>if</span>(module.hot) {
  <span class=comment>// accept update of dependency</span>
  module.hot.accept(<span class=string>"./handler.js"</span>, <span class=function><span class=keyword>function</span><span class=params>()</span> {</span>
    <span class=comment>// replace request handler of server</span>
    server.removeListener(<span class=string>"request"</span>, requestHandler);
    requestHandler = require(<span class=string>"./handler.js"</span>);
    server.on(<span class=string>"request"</span>, requestHandler);
  });
}</code></pre><h4 id=example-2-hot-replace-css><a class=anchor href=#example-2-hot-replace-css>&rarr;</a>Example 2: hot replace css</h4><pre><code><span class=comment>// addStyleTag(css: string) =&gt; HTMLStyleElement</span>
<span class=keyword>var</span> addStyleTag = require(<span class=string>"./addStyleTag"</span>);

<span class=keyword>var</span> element = addStyleTag(<span class=string>".rule { attr: name }"</span>);
module.exports = <span class=literal>null</span>;

<span class=comment>// check if HMR is enabled</span>
<span class=keyword>if</span>(module.hot) {

  <span class=comment>// accept itself</span>
  module.hot.accept();

  <span class=comment>// removeStyleTag(element: HTMLStyleElement) =&gt; void</span>
  <span class=keyword>var</span> removeStyleTag = require(<span class=string>"./removeStyleTag"</span>);

  <span class=comment>// dispose handler</span>
  module.hot.dispose(<span class=function><span class=keyword>function</span><span class=params>()</span> {</span>
    <span class=comment>// revoke the side effect</span>
    removeStyleTag(element);
  });
}</code></pre><h2 id=api><a class=anchor href=#api>&rarr;</a>API</h2><p>If HMR is enabled for a module <code>module.hot</code> is an object containing these properties:</p><h3 id=accept><a class=anchor href=#accept>&rarr;</a><code>accept</code></h3><pre><code>accept(dependencies: string[], callback: (updatedDependencies) =&gt; <span class=keyword>void</span>) =&gt; <span class=keyword>void</span>
accept(dependency: string, callback: () =&gt; <span class=keyword>void</span>) =&gt; <span class=keyword>void</span></code></pre><p>Accept code updates for the specified dependencies. The callback is called when dependencies were replaced.</p><pre><code>accept() =&gt; <span class=keyword>void</span></code></pre><p>Accept code updates for this module without notification of parents. This should only be used if the module doesn’t export anything.</p><h3 id=decline><a class=anchor href=#decline>&rarr;</a><code>decline</code></h3><pre><code>decline(dependencies: string[]) =&gt; <span class=keyword>void</span>
decline(dependency: string) =&gt; <span class=keyword>void</span></code></pre><p>Do not accept updates for the specified dependencies. If any dependencies is updated, the code update fails with code <code><span class=string>"decline"</span></code>.</p><pre><code>decline() =&gt; <span class=keyword>void</span></code></pre><p>Flag the current module as not updateable. If updated the update code would fail with code <code><span class=string>"decline"</span></code>.</p><h3 id=dispose-adddisposehandler><a class=anchor href=#dispose-adddisposehandler>&rarr;</a><code>dispose/addDisposeHandler</code></h3><pre><code>dispose(callback: (data: object) =&gt; <span class=keyword>void</span>) =&gt; <span class=keyword>void</span>
addDisposeHandler(callback: (data: object) =&gt; <span class=keyword>void</span>) =&gt; <span class=keyword>void</span></code></pre><p>Add a one time handler, which is executed when the current module code is replaced. Here you should destroy/remove any persistent resource you have claimed/created. If you want to transfer state to the new module, add it to <code>data</code> object. The <code>data</code> will be available at <code>module.hot.data</code> on the new module.</p><h3 id=removedisposehandler><a class=anchor href=#removedisposehandler>&rarr;</a><code>removeDisposeHandler</code></h3><pre><code>removeDisposeHandler(callback: (data: object) =&gt; <span class=keyword>void</span>) =&gt; <span class=keyword>void</span></code></pre><p>Remove a handler.</p><p>This can useful to add a temporary dispose handler. You could i. e. replace code while in the middle of a multi-step async function.</p><h2 id=management-api><a class=anchor href=#management-api>&rarr;</a>Management API</h2><p>Also on the <code>module.hot</code> object.</p><h3 id=setapplyonupdate><a class=anchor href=#setapplyonupdate>&rarr;</a><code>setApplyOnUpdate</code></h3><pre><code>setApplyOnUpdate(flag: boolean) =&gt; <span class=keyword>void</span></code></pre><p><code>flag == <span class=literal>false</span></code> means you have to have to manually call <code>apply()</code> if an update is ready.</p><p><code>flag == <span class=literal>true</span></code> means that it is called for you.</p><p>Default should be <code><span class=literal>true</span></code>.</p><h3 id=check><a class=anchor href=#check>&rarr;</a><code>check</code></h3><pre><code>check(callback: (err: Error, outdatedModules: Module[]) =&gt; <span class=keyword>void</span></code></pre><p>Throws an exceptions if <code>status()</code> is not <code>idle</code>.</p><p>Check all currently loaded modules for updates and apply updates if found.</p><p>If no update where found, the callback is called with <code><span class=literal>null</span></code>.</p><p>If applyOnUpdate is set the callback will be called with all modules that were disposed.</p><p>If applyOnUpdate is not set the callback will be called with all modules that will be disposed on <code>apply()</code>.</p><h3 id=apply><a class=anchor href=#apply>&rarr;</a><code>apply</code></h3><pre><code>apply(callback: (err: Error, outdatedModules: Module[]) =&gt; <span class=keyword>void</span></code></pre><p>If <code>status() != <span class=string>"ready"</span></code> it throws an error.</p><p>Continue the update process.</p><h3 id=status><a class=anchor href=#status>&rarr;</a><code>status</code></h3><pre><code>status() =&gt; string</code></pre><p>Return one of <code>idle</code>, <code>check</code>, <code>watch</code>, <code>watch-delay</code>, <code>prepare</code>, <code>ready</code>, <code>dispose</code>, <code>apply</code>, <code>abort</code> or <code>fail</code>.</p><p><code>idle</code></p><p>The HMR is waiting for your call the <code>check()</code>. When you call it the status will change to <code>check</code>.</p><p><code>check</code></p><p>The HMR is checking for updates. If it doesn’t find updates it will change back to <code>idle</code>.</p><p>If updates where found it will go through the steps <code>prepare</code>, <code>dispose</code> and <code>apply</code>. Than back to <code>idle</code>.</p><p><code>watch</code></p><p>The HMR is in watch mode and will automatically be notified about changes. After the first change it will change to <code>watch-delay</code> and wait for a specified time to start the update process. Any change will reset the timeout, to accumulate more changes. When the update process is started it will go through the steps <code>prepare</code>, <code>dispose</code> and <code>apply</code>. Than back to <code>watch</code> or <code>watch-delay</code> if changes where detected while updating.</p><p><code>prepare</code></p><p>The HMR is prepare stuff for the update. This may means that it’s downloading something.</p><p><code>ready</code></p><p>An update is available and prepared. Call <code>apply()</code> to continue.</p><p><code>dispose</code></p><p>The HMR is calling the dispose handlers of modules that will be replaced.</p><p><code>apply</code></p><p>The HMR is calling the accept handlers of the parents of replaced modules, than it requires the self accepted modules.</p><p><code>abort</code></p><p>A update cannot apply, but the system is still in a (old) consistent state.</p><p><code>fail</code></p><p>A update has thrown an exception in the middle of the process, and the system is (maybe) in a inconsistent state. The system should be restarted.</p><h3 id=status-addstatushandler><a class=anchor href=#status-addstatushandler>&rarr;</a><code>status/addStatusHandler</code></h3><pre><code>status(callback: (status: string) =&gt; <span class=keyword>void</span>) =&gt; <span class=keyword>void</span>
addStatusHandler(callback: (status: string) =&gt; <span class=keyword>void</span>) =&gt; <span class=keyword>void</span></code></pre><p>Register a callback on status change.</p><h3 id=removestatushandler><a class=anchor href=#removestatushandler>&rarr;</a><code>removeStatusHandler</code></h3><pre><code>removeStatusHandler(callback: (status: string) =&gt; <span class=keyword>void</span>) =&gt; <span class=keyword>void</span></code></pre><p>Remove a registered status change handler.</p><h2 id=how-to-care-with><a class=anchor href=#how-to-care-with>&rarr;</a>How to care with …</h2><h4 id=a-module-without-side-effects><a class=anchor href=#a-module-without-side-effects>&rarr;</a>… a module without side effects (the standard case)</h4><p>Nothing to do in the module. Any parent can accept it.</p><h4 id=a-module-with-side-effects><a class=anchor href=#a-module-with-side-effects>&rarr;</a>… a module with side effects</h4><p>The module needs a dispose handler, than any parent can accept it.</p><h4 id=a-module-with-only-side-effects-and-no-exports><a class=anchor href=#a-module-with-only-side-effects-and-no-exports>&rarr;</a>… a module with only side effects and no exports</h4><p>The module needs a dispose handler and can accept itself. No action is required in the parent.</p><p>If the module’s code is not in your hand, the parent can accept the module with some custom dispose logic.</p><h4 id=the-application-entry-module><a class=anchor href=#the-application-entry-module>&rarr;</a>… the application entry module</h4><p>As it doesn’t export it can accept itself. A dispose handler can pass the application state on replacement.</p><h4 id=external-module-with-not-handleable-side-effects><a class=anchor href=#external-module-with-not-handleable-side-effects>&rarr;</a>… external module with not handleable side effects</h4><p>In the nearest parent you decline the dependency. This makes your application throw on update. But as it’s an external module, an update is very rar.</p></div></div></div></div></div><a href=https://github.com/webpack/webpack><img style="position: absolute; top: 0; left: 0; border: 0" src=https://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png alt="Fork me on GitHub"></a>