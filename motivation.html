<!DOCTYPE html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=""><meta name=author content=""><link rel=icon type=image/png href=/assets/favicon.png><link rel=stylesheet href=css/doc.css><title>motivation</title><body><script src=js/doc.js charset=utf-8 async></script><div class=container><div class=row><div class="col-md-3 nav"><div class=logo><ul class=cube-inner><li class=front></li><li class=back></li><li class=right></li><li class=left></li><li class=top></li><li class=bottom></li></ul><ul class=cube><li class=front></li><li class=back></li><li class=right></li><li class=left></li><li class=top></li><li class=bottom></li><li class=floor></li></ul></div><div class=name>webpack</div><div class=tagline>MODULE BUNDLER</div><div class=sidebar><ul><li><a href=.>Home</a></li></ul><ul><li>Getting Started<ul><li><a href=motivation.html>Motivation</a></li><li><a href=what-is-webpack.html>What is webpack?</a></li><li><a href=installation.html>Installation</a></li><li><a href=usage.html>Usage</a></li><li>Require Modules</li><li>Vendor Modules</li><li><a href=using-loaders.html>Using Loaders</a></li><li><a href=using-plugins.html>Using Plugins</a></li><li><a href=dev-tools.html>Dev Tools</a></li></ul></li><li>tutorials and examples<ul><li><a href="http://webpack.github.io/docs/tutorials/getting-started/">Getting started</a></li><li><a href=list-of-tutorials.html>List of tutorials</a></li><li><a href=examples.html>examples</a></li></ul></li><li>Guides<ul><li><a href=commonjs.html>CommonJs</a></li><li><a href=amd.html>AMD</a></li><li><a href=webpack-for-browserify-users.html>webpack for browserify users</a></li><li><a href=code-splitting.html>Code Splitting</a></li><li><a href=stylesheets.html>Stylesheets</a></li><li><a href=optimization.html>Optimization</a></li><li><a href=long-term-caching.html>Long-term Caching</a></li><li><a href=how-to-write-a-loader.html>How to write a loader</a></li><li>How to write a plugin</li><li><a href=multiple-entry-points.html>Multiple entry points</a></li><li><a href=library-and-externals.html>Library and externals</a></li><li><a href=shimming-modules.html>Shimming modules</a></li><li><a href=testing.html>Testing</a></li><li><a href=build-performance.html>Build performance</a></li><li><a href=hot-module-replacement-with-webpack.html>Hot Module Replacement with webpack</a></li><li><a href=comparison.html>Comparison</a></li></ul></li><li>webpack with<ul><li><a href=usage-with-grunt.html>grunt</a></li><li><a href=usage-with-gulp.html>gulp</a></li><li><a href=usage-with-bower.html>bower</a></li><li><a href=usage-with-karma.html>karma</a></li></ul></li><li>Lists<ul><li><a href=loader-conventions.html>loader conventions</a></li><li><a href=list-of-loaders.html>List of loaders</a></li><li><a href=list-of-plugins.html>List of plugins</a></li><li><a href=list-of-tutorials.html>List of tutorials</a></li></ul></li><li>API<ul><li><a href=configuration.html>Configuration</a></li><li><a href=cli.html>CLI</a></li><li><a href=node.js-api.html>Node.js API</a></li><li><a href=api-in-modules.html>API in modules</a></li><li><a href=loaders.html>Loaders</a></li><li><a href=plugins.html>Plugins</a></li><li><a href=context.html>Context</a></li><li><a href=resolving.html>Resolving</a></li><li><a href=hot-module-replacement.html>Hot Module Replacement</a></li><li>Dev Tools<ul><li><a href=webpack-dev-server.html>webpack-dev-server</a></li><li><a href=webpack-dev-middleware.html>webpack-dev-middleware</a></li></ul></li></ul></li><li>Development<ul><li><a href=changelog.html>Changelog</a></li><li><a href=roadmap.html>Roadmap</a></li><li><a href=ideas.html>Ideas</a></li><li>Contributing</li></ul></li></ul></div></div><div class=col-md-9><div class=announcement><div class=announcement-inner><em>2014-07-04</em> Help to improve webpack by filling out <a href=https://docs.google.com/forms/d/101ZcujnVL8l575T6VRl62SfrVj5FZC1IzwMH1258GVc/viewform>this little survey</a>. Thanks!</div></div><div class=pull-right><a href=https://github.com/webpack/docs/wiki/motivation/_edit id=wikieditlink>Edit</a></div><div class=row><div class="col-md-12 page-header"><h1 id=wikititle>motivation</h1></div></div><div class=row><div id=wiki class=col-md-12><div class=contents><ul><li><a href=#module-system-styles>Module system styles</a><ul><li><a href=#script-tag-style><code>&lt;script&gt;</code>-tag style</a></li><li><a href=#commonjs-synchronous-require>CommonJs: synchronous <code>require</code></a></li><li><a href=#amd-asynchronous-require>AMD: asynchronous require</a></li><li><a href=#es6-modules>ES6 modules</a></li><li><a href=#unbiased-solution>Unbiased solution</a></li></ul></li><li><a href=#transferring>Transferring</a><ul><li><a href=#chunked-transferring>Chunked transferring</a></li></ul></li><li><a href=#why-only-javascript>Why only javascript?</a></li><li><a href=#static-analysis>Static analysis</a><ul><li><a href=#strategy>Strategy</a></li></ul></li></ul></div><p>Today websites are evolving into web apps:</p><ul><li>More and more javascript is in a page.</li><li>You can do more stuff in modern browsers.</li><li>Fewer full page reloads → even more code in a page.</li></ul><p>As a result there is a <strong>lot</strong> of code on the client side!</p><p>A big code base needs to be organized. Module systems offer the option to split your code base into modules.</p><h1 id=module-system-styles><a class=anchor href=#module-system-styles>&rarr;</a>Module system styles</h1><p>There are multiple standards how to define dependencies and export values:</p><ul><li><code>&lt;script&gt;</code>-tag style (without a module system)</li><li>CommonJs</li><li>AMD and some dialects of it</li><li>ES6 modules</li><li>and more…</li></ul><h2 id=script-tag-style><a class=anchor href=#script-tag-style>&rarr;</a><code>&lt;script&gt;</code>-tag style</h2><p>This is the way you would handle a modularized code base if you didn’t use a module system.</p><pre><code><span class=tag>&lt;<span class=title>script</span> <span class=attribute>src</span>=<span class=value>"module1.js"</span>&gt;</span><span class=javascript></span><span class=tag>&lt;/<span class=title>script</span>&gt;</span>
<span class=tag>&lt;<span class=title>script</span> <span class=attribute>src</span>=<span class=value>"module2.js"</span>&gt;</span><span class=javascript></span><span class=tag>&lt;/<span class=title>script</span>&gt;</span>
<span class=tag>&lt;<span class=title>script</span> <span class=attribute>src</span>=<span class=value>"libaryA.js"</span>&gt;</span><span class=javascript></span><span class=tag>&lt;/<span class=title>script</span>&gt;</span>
<span class=tag>&lt;<span class=title>script</span> <span class=attribute>src</span>=<span class=value>"module3.js"</span>&gt;</span><span class=javascript></span><span class=tag>&lt;/<span class=title>script</span>&gt;</span></code></pre><p>Modules export an interface to the global object, i. e. the <code>window</code> object. Modules can access the interface of dependencies over the global object.</p><h4 id=common-problems><a class=anchor href=#common-problems>&rarr;</a>Common problems</h4><ul><li>Conflicts in the global object.</li><li>Order of loading is important.</li><li>Developer have to resolve dependencies of modules/libraries.</li><li>In big projects the list can get really long and difficult to manage.</li></ul><h2 id=commonjs-synchronous-require><a class=anchor href=#commonjs-synchronous-require>&rarr;</a>CommonJs: synchronous <code>require</code></h2><p>This style uses a synchronous <code>require</code> method to load a dependency and return an exported interface. A module can specify exports by adding properties to the <code>exports</code> object or setting the value of <code>module.exports</code>.</p><pre><code>require(<span class=string>"module"</span>);
require(<span class=string>"../file.js"</span>);
exports.doStuff = <span class=function><span class=keyword>function</span><span class=params>()</span> {</span>};
module.exports = someValue;</code></pre><p>It’s used on server-side by <a href=http://nodejs.org>node.js</a>.</p><h4 id=pros><a class=anchor href=#pros>&rarr;</a>Pros</h4><ul><li>Server-side modules can be reused</li><li>There are already many modules in this style (npm)</li><li>very simple and easy to use.</li></ul><h4 id=cons><a class=anchor href=#cons>&rarr;</a>Cons</h4><ul><li>blocking calls do not apply well on networks. Network requests are asynchronous.</li><li>No parallel require of multiple modules</li></ul><h4 id=implementations><a class=anchor href=#implementations>&rarr;</a>Implementations</h4><ul><li><a href="http://nodejs.org/">node.js</a> - server-side</li><li><a href=https://github.com/substack/node-browserify>browserify</a> - compile to one bundle</li><li><a href=https://github.com/medikoo/modules-webmake>modules-webmake</a> - compile to one bundle</li><li><a href=https://github.com/substack/wreq>wreq</a> - client-side</li></ul><h2 id=amd-asynchronous-require><a class=anchor href=#amd-asynchronous-require>&rarr;</a>AMD: asynchronous require</h2><p><a href=https://github.com/amdjs/amdjs-api/wiki/AMD><code>Asynchronous Module Definition</code></a></p><p>Other module systems (for the browser) had problems with the synchronous <code>require</code> (CommonJs) and introduced an asynchronous version (and a way to define modules and exporting values):</p><pre><code>require([<span class=string>"module"</span>, <span class=string>"../file"</span>], <span class=function><span class=keyword>function</span><span class=params>(module, file)</span> {</span> <span class=comment>/* ... */</span> });
define(<span class=string>"mymodule"</span>, [<span class=string>"dep1"</span>, <span class=string>"dep2"</span>], <span class=function><span class=keyword>function</span><span class=params>(d1, d2)</span> {</span>
  <span class=keyword>return</span> someExportedValue;
});</code></pre><h4 id=pros><a class=anchor href=#pros>&rarr;</a>Pros</h4><ul><li>Fits to the asynchronous request style in networks.</li><li>Parallel loading of multiple modules.</li></ul><h4 id=cons><a class=anchor href=#cons>&rarr;</a>Cons</h4><ul><li>Coding overhead. More difficult to read and write.</li><li>Seems to be some kind of workaround.</li></ul><h4 id=implementations><a class=anchor href=#implementations>&rarr;</a>Implementations</h4><ul><li><a href="http://requirejs.org/">require.js</a> - client-side</li><li><a href=https://github.com/cujojs/curl>curl</a> - client-side</li></ul><p>Read more about <a href=commonjs.html>CommonJs</a> and <a href=amd.html>AMD</a>.</p><h2 id=es6-modules><a class=anchor href=#es6-modules>&rarr;</a>ES6 modules</h2><p>EcmaScript6 adds same language constructs to Javascript, which form another module system.</p><pre><code>import <span class=string>"jquery"</span>;
export <span class=function><span class=keyword>function</span> <span class=title>doStuff</span><span class=params>()</span> {</span>}
module <span class=string>"localModule"</span> {}</code></pre><h4 id=pros><a class=anchor href=#pros>&rarr;</a>Pros</h4><ul><li>Static analysis is easy</li><li>Future-prove as ES standard</li></ul><h4 id=cons><a class=anchor href=#cons>&rarr;</a>Cons</h4><ul><li>Native browser support will take time</li><li>Very few modules in this style</li></ul><h2 id=unbiased-solution><a class=anchor href=#unbiased-solution>&rarr;</a>Unbiased solution</h2><p>Give the developer the choice of the module style. Allow existing code to work. Make it easy to add custom module styles.</p><hr><h1 id=transferring><a class=anchor href=#transferring>&rarr;</a>Transferring</h1><p>Modules should be executed on the client, so they must be transferred from the server to the browser.</p><p>There are two extremes on how to transfer modules:</p><ul><li>1 request per module (i. e. require.js)</li><li>all modules in one request (i. e. browserify and require.js when compiled)</li></ul><p>Both are used in the wild, but both are suboptimal:</p><ul><li>1 request per module<ul><li>Pro: only required modules are transferred</li><li>Con: many requests means much overhead</li><li>Con: slow application startup, because of request latency</li></ul></li><li>all modules in one request<ul><li>Pro: less request overhead, less latency</li><li>Con: not (yet) required modules are transferred too</li></ul></li></ul><h2 id=chunked-transferring><a class=anchor href=#chunked-transferring>&rarr;</a>Chunked transferring</h2><p>A more flexible transferring is be better. A compromise between the extremes is better in most cases.</p><p>→ While compiling all modules: Split the set of modules into multiple smaller batches (chunks).</p><p>We get multiple smaller requests. Chunks with modules that are not required initially are only requested on demand. The initial request doesn’t contain your complete code base and is smaller.</p><p>The “split points” are up to the developer and optional.</p><p>→ A big code base is possible!</p><p>Note: The <a href=https://developers.google.com/web-toolkit/doc/latest/DevGuideCodeSplitting>idea is from Google’s GWT</a>.</p><p>Read more about <a href=code-splitting.html>Code Splitting</a>.</p><hr><h1 id=why-only-javascript><a class=anchor href=#why-only-javascript>&rarr;</a>Why only javascript?</h1><p>Why should a module system only help the developer with javascript? There are many other static resources that need to the handled:</p><ul><li>stylesheets</li><li>images</li><li>webfonts</li><li>html for templating</li><li>etc.</li></ul><p>And also:</p><ul><li>coffeescript → javascript</li><li>less stylesheets → css stylesheets</li><li>jade templates → javascript which generates html</li><li>i18n files → something</li><li>etc.</li></ul><p>This should be as easy as:</p><pre><code>require(<span class=string>"./style.css"</span>);</code></pre><pre><code>require(<span class=string>"./style.less"</span>);
require(<span class=string>"./template.jade"</span>);
require(<span class=string>"./image.png"</span>);</code></pre><p>Read more about <a href=using-loaders.html>Using loaders</a> and <a href=loaders.html>Loaders</a>.</p><hr><h1 id=static-analysis><a class=anchor href=#static-analysis>&rarr;</a>Static analysis</h1><p>When compiling all the modules a static analysis tries to find dependencies.</p><p>Traditionally this could only find simple stuff without expression, but i. e. <code>require(<span class=string>"./template/"</span> + templateName + <span class=string>".jade"</span>)</code> is a common construct.</p><p>Many libraries are written in different styles. Some of them are very weird…</p><h2 id=strategy><a class=anchor href=#strategy>&rarr;</a>Strategy</h2><p>A clever parser would allow most existing code to run. If the developer does something weird try to find the most compatible solution.</p></div></div></div></div></div><a href=https://github.com/webpack/webpack><img style="position: absolute; top: 0; left: 0; border: 0" src=https://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png alt="Fork me on GitHub"></a>