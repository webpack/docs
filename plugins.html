<!DOCTYPE html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=""><meta name=author content=""><link rel=icon type=image/png href="/assets/favicon.png"><link rel=stylesheet href=https://cdn.jsdelivr.net/docsearch.js/2.1.8/docsearch.min.css integrity=sha384-/h/CVRynn/dNPld+6a4vrwfa+2rmLNF4BIustqdtI2P8kqtFvUOsgA+TXqp+6F04 crossorigin=anonymous><link rel=stylesheet href="css/doc.css"><title>plugins</title><body><script src=https://cdn.jsdelivr.net/docsearch.js/2.1.8/docsearch.min.js integrity=sha384-u5+p4sI6IAzw0829Aqivzf5sJed6yKCHDofUkWCK5Zs6w/DQr9JleVL3lrVLgufR crossorigin=anonymous async></script><script src=js/doc.js charset=utf-8 async></script><div class=container><div class=row><div class="col-md-3 nav"><div class=logo><ul class=cube-inner><li class=front></li><li class=back></li><li class=right></li><li class=left></li><li class=top></li><li class=bottom></li></ul><ul class=cube><li class=front></li><li class=back></li><li class=right></li><li class=left></li><li class=top></li><li class=bottom></li><li class=floor></li></ul></div><div class=name>webpack</div><div class=tagline>MODULE BUNDLER</div><div class=sidebar><input id=docsearch><ul><li><a href=.>Home</a></li></ul><ul><li>Getting Started<ul><li><a href=motivation.html>Motivation</a></li><li><a href=what-is-webpack.html>What is webpack?</a></li><li><a href=usage.html>Usage</a></li><li>Require Modules</li><li>Vendor Modules</li><li><a href=using-loaders.html>Using Loaders</a></li><li><a href=using-plugins.html>Using Plugins</a></li><li><a href=dev-tools.html>Dev Tools</a></li><li><a href=troubleshooting.html>Troubleshooting</a></li></ul></li><li>Tutorials and examples<ul><li><a href="http://webpack.github.io/docs/tutorials/getting-started/">Getting started</a></li><li><a href=list-of-tutorials.html>List of tutorials</a></li><li><a href=examples.html>examples</a></li></ul></li><li>Guides<ul><li><a href=commonjs.html>CommonJs</a></li><li><a href=amd.html>AMD</a></li><li><a href=webpack-for-browserify-users.html>webpack for browserify users</a></li><li><a href=code-splitting.html>Code Splitting</a></li><li><a href=stylesheets.html>Stylesheets</a></li><li><a href=optimization.html>Optimization</a></li><li><a href=long-term-caching.html>Long-term Caching</a></li><li><a href=how-to-write-a-loader.html>How to write a loader</a></li><li><a href=how-to-write-a-plugin.html>How to write a plugin</a></li><li><a href=multiple-entry-points.html>Multiple entry points</a></li><li><a href=library-and-externals.html>Library and externals</a></li><li><a href=shimming-modules.html>Shimming modules</a></li><li><a href=testing.html>Testing</a></li><li><a href=build-performance.html>Build performance</a></li><li><a href=hot-module-replacement-with-webpack.html>Hot Module Replacement with webpack</a></li><li><a href=comparison.html>Comparison</a></li></ul></li><li>webpack with<ul><li><a href=usage-with-grunt.html>grunt</a></li><li><a href=usage-with-gulp.html>gulp</a></li><li><a href=usage-with-bower.html>bower</a></li><li><a href=usage-with-karma.html>karma</a></li></ul></li><li>Lists<ul><li><a href=loader-conventions.html>loader conventions</a></li><li><a href=list-of-loaders.html>List of loaders</a></li><li><a href=list-of-plugins.html>List of plugins</a></li><li><a href=list-of-tutorials.html>List of tutorials</a></li><li><a href=list-of-hints.html>List of hints</a></li></ul></li><li>API<ul><li><a href=configuration.html>Configuration</a></li><li><a href=cli.html>CLI</a></li><li><a href=node.js-api.html>Node.js API</a></li><li><a href=api-in-modules.html>API in modules</a></li><li><a href=loaders.html>Loaders</a></li><li><a href=plugins.html>Plugins</a></li><li><a href=context.html>Context</a></li><li><a href=resolving.html>Resolving</a></li><li><a href=hot-module-replacement.html>Hot Module Replacement</a></li><li>Dev Tools<ul><li><a href=webpack-dev-server.html>webpack-dev-server</a></li><li><a href=webpack-dev-middleware.html>webpack-dev-middleware</a></li></ul></li></ul></li><li>Development<ul><li><a href=changelog.html>Changelog</a></li><li><a href=roadmap.html>Roadmap</a></li><li><a href=ideas.html>Ideas</a></li><li>Contributing</li></ul></li></ul></div></div><div class=col-md-9><!--<div class="announcement">
						<div class="announcement-inner">
							<em>2014-07-04</em> Help to improve webpack by filling out <a href="https://docs.google.com/forms/d/101ZcujnVL8l575T6VRl62SfrVj5FZC1IzwMH1258GVc/viewform">this little survey</a>. Thanks!<br>
							<em>2015-03-04</em> You can now comment doc pages (on the bottom of the page). Free feel to add comments about missing/unclear stuff or fix stuff that other people find unclear. You can use the Edit button on the top right corner.
						</div>
					</div>--><div class=pull-right><a href=https://github.com/webpack/docs/wiki/plugins/_edit class=wikieditlink>Edit</a></div><div class=row><div class="col-md-12 page-header"><h1 id=wikititle>plugins</h1></div></div><div class="row deprecation"><div class=col-md-12>webpack v1 is deprecated. We encourage all developers to upgrade to webpack 2.</div><div class=col-md-12>Follow our <a href="https://webpack.js.org/guides/migrating/" title="Migration guide">migration guide</a> or refer to <a href="https://webpack.js.org/concepts/" title="webpack 2 documentation">webpack 2 documentation</a> for more info.</div></div><div class=row><div id=wiki class=col-md-12><div class=contents><ul><li><a href=#the-compiler-instance>The <code>Compiler</code> instance</a></li><li><a href=#the-compilation-instance>The <code>Compilation</code> instance</a></li><li><a href=#the-maintemplate-instance>The <code>MainTemplate</code> instance</a></li><li><a href=#the-parser-instance>The <code>Parser</code> instance</a></li><li><a href=#the-normalmodulefactory>The <code>NormalModuleFactory</code></a></li><li><a href=#the-contextmodulefactory>The <code>ContextModuleFactory</code></a></li><li><a href=#resolvers>Resolvers</a></li></ul></div><p>For a high-level introduction to writing plugins, start with <a href=https://github.com/webpack/docs/wiki/How-to-write-a-plugin>How to write a plugin</a>.</p><p>Many objects in Webpack extend the Tapable class, which exposes a <code>plugin</code> method. And with the <code>plugin</code> method, plugins can inject custom build steps. You will see <code>compiler.plugin</code> and <code>compilation.plugin</code> used a lot. Essentially, each one of these plugin calls binds a callback to fire at specific steps throughout the build process.</p><p>A plugin is installed once as Webpack starts up. Webpack installs a plugin by calling its <code>apply</code> method, and passes a reference to the Webpack <code>compiler</code> object. You may then call <code>compiler.plugin</code> to access asset compilations and their individual build steps. An example would look like this:</p><pre><code><span class=comment>// MyPlugin.js</span>

<span class=function><span class=keyword>function</span> <span class=title>MyPlugin</span><span class=params>(options)</span> {</span>
  <span class=comment>// Configure your plugin with options...</span>
}

MyPlugin.prototype.apply = <span class=function><span class=keyword>function</span><span class=params>(compiler)</span> {</span>
  compiler.plugin(<span class=string>"compile"</span>, <span class=function><span class=keyword>function</span><span class=params>(params)</span> {</span>
    console.log(<span class=string>"The compiler is starting to compile..."</span>);
  });

  compiler.plugin(<span class=string>"compilation"</span>, <span class=function><span class=keyword>function</span><span class=params>(compilation)</span> {</span>
    console.log(<span class=string>"The compiler is starting a new compilation..."</span>);

    compilation.plugin(<span class=string>"optimize"</span>, <span class=function><span class=keyword>function</span><span class=params>()</span> {</span>
      console.log(<span class=string>"The compilation is starting to optimize files..."</span>);
    });
  });

  compiler.plugin(<span class=string>"emit"</span>, <span class=function><span class=keyword>function</span><span class=params>(compilation, callback)</span> {</span>
    console.log(<span class=string>"The compilation is going to emit files..."</span>);
    callback();
  });
};

module.exports = MyPlugin;</code></pre><p>Then in <code>webpack.config.js</code></p><pre><code>    plugins: [
        <span class=keyword>new</span> MyPlugin({options: <span class=string>'nada'</span>})
    ]</code></pre><h3 id=note-on-interface-types><a class=anchor href=#note-on-interface-types>&rarr;</a>Note on interface types…</h3><p>There are two types of plugin interfaces.</p><ul><li><p>Timing based</p><ul><li>sync (default): As seen above. Use return.</li><li>async: Last parameter is a callback. Signature: function(err, result)</li><li>parallel: The handlers are invoked parallel (async).</li></ul></li><li><p>Return value</p><ul><li>not bailing (default): No return value.</li><li>bailing: The handlers are invoked in order until one handler returns something.</li><li>parallel bailing: The handlers are invoked in parallel (async). The first returned value (by order) is significant.</li><li>waterfall: Each handler gets the result value of the last handler as an argument.</li></ul></li></ul><h1 id=the-compiler-instance><a class=anchor href=#the-compiler-instance>&rarr;</a>The <code>Compiler</code> instance</h1><p>Plugins need to have the apply method on their prototype chain (or bound to) in order to have access to the compiler instance.</p><pre><code>
<span class=comment>//MyPlugin.js</span>

<span class=function><span class=keyword>function</span> <span class=title>MyPlugin</span><span class=params>()</span> {</span>};
MyPlugin.prototype.apply = <span class=function><span class=keyword>function</span> <span class=params>(compiler)</span> {</span>
    <span class=comment>//now you have access to all the compiler instance methods</span>
}
module.exports = MyPlugin;</code></pre><p>Something like this should also work</p><pre><code><span class=comment>//MyFunction.js</span>

<span class=function><span class=keyword>function</span> <span class=title>apply</span><span class=params>(options, compiler)</span> {</span>
    <span class=comment>//now you have access to the compiler instance</span>
    <span class=comment>//and options</span>
}

<span class=comment>//this little trick makes it easier to pass and check options to the plugin</span>
module.exports = <span class=function><span class=keyword>function</span><span class=params>(options)</span> {</span>
    <span class=keyword>if</span> (options <span class=keyword>instanceof</span> Array) {
        options = {
            include: options
        };
    }

    <span class=keyword>if</span> (!Array.isArray(options.include)) {
        options.include = [ options.include ];
    }

    <span class=keyword>return</span> {
        apply: apply.bind(<span class=keyword>this</span>, options)
    };
};</code></pre><h4 id=run-async><a class=anchor href=#run-async>&rarr;</a><code>run(compiler: Compiler)</code> async</h4><p>The <code>run</code> method of the Compiler is used to start a compilation. This is not called in watch mode.</p><h4 id=watch-run-async><a class=anchor href=#watch-run-async>&rarr;</a><code>watch-run(watching: Watching)</code> async</h4><p>The <code>watch</code> method of the Compiler is used to start a watching compilation. This is not called in normal mode.</p><h4 id=compilation><a class=anchor href=#compilation>&rarr;</a><code>compilation(c: Compilation, params: Object)</code></h4><p>A <code>Compilation</code> is created. A plugin can use this to obtain a reference to the <code>Compilation</code> object. The <code>params</code> object contains useful references.</p><h4 id=normal-module-factory><a class=anchor href=#normal-module-factory>&rarr;</a><code>normal-module-factory(nmf: NormalModuleFactory)</code></h4><p>A <code>NormalModuleFactory</code> is created. A plugin can use this to obtain a reference to the <code>NormalModuleFactory</code> object.</p><pre><code>
compiler.plugin(<span class=string>"normal-module-factory"</span>, <span class=function><span class=keyword>function</span><span class=params>(nmf)</span> {</span>
    nmf.plugin(<span class=string>"after-resolve"</span>, <span class=function><span class=keyword>function</span><span class=params>(data)</span> {</span>
        data.loaders.unshift(path.join(__dirname, <span class=string>"postloader.js"</span>));
    });
});</code></pre><h4 id=context-module-factory><a class=anchor href=#context-module-factory>&rarr;</a><code>context-module-factory(cmf: ContextModuleFactory)</code></h4><p>A <code>ContextModuleFactory</code> is created. A plugin can use this to obtain a reference to the <code>ContextModuleFactory</code> object.</p><h4 id=compile><a class=anchor href=#compile>&rarr;</a><code>compile(params)</code></h4><p>The Compiler starts compiling. This is used in normal and watch mode. Plugins can use this point to modify the <code>params</code> object (i. e. to decorate the factories).</p><pre><code>compiler.plugin(<span class=string>"compile"</span>, <span class=function><span class=keyword>function</span><span class=params>(params)</span> {</span>
    <span class=comment>//you are now in the "compile" phase</span>
});</code></pre><h4 id=make-parallel><a class=anchor href=#make-parallel>&rarr;</a><code>make(c: Compilation)</code> parallel</h4><p>Plugins can use this point to add entries to the compilation or prefetch modules. They can do this by calling <code>addEntry(context, entry, name, callback)</code> or <code>prefetch(context, dependency, callback)</code> on the Compilation.</p><h4 id=after-compile-async><a class=anchor href=#after-compile-async>&rarr;</a><code>after-compile(c: Compilation)</code> async</h4><p>The compile process is finished and the modules are sealed. The next step is to emit the generated stuff. Here modules can use the results in some cool ways.</p><p>The handlers are not copied to child compilers.</p><h4 id=emit-async><a class=anchor href=#emit-async>&rarr;</a><code>emit(c: Compilation)</code> async</h4><p>The Compiler begins with emitting the generated assets. Here plugins have the last chance to add assets to the <code>c.assets</code> array.</p><h4 id=after-emit-async><a class=anchor href=#after-emit-async>&rarr;</a><code>after-emit(c: Compilation)</code> async</h4><p>The Compiler has emitted all assets.</p><h4 id=done><a class=anchor href=#done>&rarr;</a><code>done(stats: Stats)</code></h4><p>All is done.</p><h4 id=failed><a class=anchor href=#failed>&rarr;</a><code>failed(err: Error)</code></h4><p>The Compiler is in watch mode and a compilation has failed hard.</p><h4 id=invalid><a class=anchor href=#invalid>&rarr;</a><code>invalid()</code></h4><p>The Compiler is in watch mode and a file change is detected. The compilation will be begin shortly (<code>options.watchDelay</code>).</p><h4 id=after-plugins><a class=anchor href=#after-plugins>&rarr;</a><code>after-plugins()</code></h4><p>All plugins extracted from the options object are added to the compiler.</p><h4 id=after-resolvers><a class=anchor href=#after-resolvers>&rarr;</a><code>after-resolvers()</code></h4><p>All plugins extracted from the options object are added to the resolvers.</p><h1 id=the-compilation-instance><a class=anchor href=#the-compilation-instance>&rarr;</a>The <code>Compilation</code> instance</h1><p>The Compilation instance extends from the compiler. ie. compiler.compilation It is the literal compilation of all the objects in the require graph. This object has access to all the modules and their dependencies (most of which are circular references). In the compilation phase, modules are loaded, sealed, optimized, chunked, hashed and restored, etc. This would be the main lifecycle of any operations of the compilation.</p><pre><code>compiler.plugin(<span class=string>"compilation"</span>, <span class=function><span class=keyword>function</span><span class=params>(compilation)</span> {</span>
    <span class=comment>//the main compilation instance</span>
    <span class=comment>//all subsequent methods are derived from compilation.plugin</span>
});</code></pre><h4 id=normal-module-loader><a class=anchor href=#normal-module-loader>&rarr;</a><code>normal-module-loader</code></h4><p>The normal module loader, is the function that actually loads all the modules in the module graph (one-by-one).</p><pre><code>compilation.plugin(<span class=string>'normal-module-loader'</span>, <span class=function><span class=keyword>function</span><span class=params>(loaderContext, module)</span> {</span>
    <span class=comment>//this is where all the modules are loaded</span>
    <span class=comment>//one by one, no dependencies are created yet</span>
});</code></pre><h4 id=seal><a class=anchor href=#seal>&rarr;</a><code>seal</code></h4><p>The sealing of the compilation has started.</p><pre><code>compilation.plugin(<span class=string>'seal'</span>, <span class=function><span class=keyword>function</span><span class=params>()</span> {</span>
    <span class=comment>//you are not accepting any more modules</span>
    <span class=comment>//no arguments</span>
});</code></pre><h4 id=optimize><a class=anchor href=#optimize>&rarr;</a><code>optimize</code></h4><p>Optimize the compilation.</p><pre><code>compilation.plugin(<span class=string>'optimize'</span>, <span class=function><span class=keyword>function</span><span class=params>()</span> {</span>
    <span class=comment>//webpack is begining the optimization phase</span>
    <span class=comment>// no arguments</span>
});</code></pre><h4 id=optimize-tree-async><a class=anchor href=#optimize-tree-async>&rarr;</a><code>optimize-tree(chunks, modules)</code> async</h4><p>Async optimization of the tree.</p><pre><code>compilation.plugin(<span class=string>'optimize-tree'</span>, <span class=function><span class=keyword>function</span><span class=params>(chunks, modules)</span> {</span>

});</code></pre><h4 id=optimize-modules><a class=anchor href=#optimize-modules>&rarr;</a><code>optimize-modules(modules: Module[])</code></h4><p>Optimize the modules.</p><pre><code>compilation.plugin(<span class=string>'optimize-modules'</span>, <span class=function><span class=keyword>function</span><span class=params>(modules)</span> {</span>
    <span class=comment>//handle to the modules array during tree optimization</span>
});</code></pre><h4 id=after-optimize-modules><a class=anchor href=#after-optimize-modules>&rarr;</a><code>after-optimize-modules(modules: Module[])</code></h4><p>Optimizing the modules has finished.</p><h4 id=optimize-chunks><a class=anchor href=#optimize-chunks>&rarr;</a><code>optimize-chunks(chunks: Chunk[])</code></h4><p>Optimize the chunks.</p><pre><code><span class=comment>//optimize chunks may be run several times in a compilation</span>

compilation.plugin(<span class=string>'optimize-chunks'</span>, <span class=function><span class=keyword>function</span><span class=params>(chunks)</span> {</span>
    <span class=comment>//unless you specified multiple entries in your config</span>
    <span class=comment>//there's only one chunk at this point</span>
    chunks.forEach(<span class=function><span class=keyword>function</span> <span class=params>(chunk)</span> {</span>
        <span class=comment>//chunks have circular references to their modules</span>
        chunk.modules.forEach(<span class=function><span class=keyword>function</span> <span class=params>(module)</span>{</span>
            <span class=comment>//module.loaders, module.rawRequest, module.dependencies, etc.</span>
        }); 
    });
});</code></pre><h4 id=after-optimize-chunks><a class=anchor href=#after-optimize-chunks>&rarr;</a><code>after-optimize-chunks(chunks: Chunk[])</code></h4><p>Optimizing the chunks has finished.</p><h4 id=revive-modules><a class=anchor href=#revive-modules>&rarr;</a><code>revive-modules(modules: Module[], records)</code></h4><p>Restore module info from records.</p><h4 id=optimize-module-order><a class=anchor href=#optimize-module-order>&rarr;</a><code>optimize-module-order(modules: Module[])</code></h4><p>Sort the modules in order of importance. The first is the most important module. It will get the smallest id.</p><h4 id=optimize-module-ids><a class=anchor href=#optimize-module-ids>&rarr;</a><code>optimize-module-ids(modules: Module[])</code></h4><p>Optimize the module ids.</p><h4 id=after-optimize-module-ids><a class=anchor href=#after-optimize-module-ids>&rarr;</a><code>after-optimize-module-ids(modules: Module[])</code></h4><p>Optimizing the module ids has finished.</p><h4 id=record-modules><a class=anchor href=#record-modules>&rarr;</a><code>record-modules(modules: Module[], records)</code></h4><p>Store module info to the records.</p><h4 id=revive-chunks><a class=anchor href=#revive-chunks>&rarr;</a><code>revive-chunks(chunks: Chunk[], records)</code></h4><p>Restore chunk info from records.</p><h4 id=optimize-chunk-order><a class=anchor href=#optimize-chunk-order>&rarr;</a><code>optimize-chunk-order(chunks: Chunk[])</code></h4><p>Sort the chunks in order of importance. The first is the most important chunk. It will get the smallest id.</p><h4 id=optimize-chunk-ids><a class=anchor href=#optimize-chunk-ids>&rarr;</a><code>optimize-chunk-ids(chunks: Chunk[])</code></h4><p>Optimize the chunk ids.</p><h4 id=after-optimize-chunk-ids><a class=anchor href=#after-optimize-chunk-ids>&rarr;</a><code>after-optimize-chunk-ids(chunks: Chunk[])</code></h4><p>Optimizing the chunk ids has finished.</p><h4 id=record-chunks><a class=anchor href=#record-chunks>&rarr;</a><code>record-chunks(chunks: Chunk[], records)</code></h4><p>Store chunk info to the records.</p><h4 id=before-hash><a class=anchor href=#before-hash>&rarr;</a><code>before-hash</code></h4><p>Before the compilation is hashed.</p><h4 id=after-hash><a class=anchor href=#after-hash>&rarr;</a><code>after-hash</code></h4><p>After the compilation is hashed.</p><h4 id=before-chunk-assets><a class=anchor href=#before-chunk-assets>&rarr;</a><code>before-chunk-assets</code></h4><p>Before creating the chunk assets.</p><h4 id=additional-chunk-assets><a class=anchor href=#additional-chunk-assets>&rarr;</a><code>additional-chunk-assets(chunks: Chunk[])</code></h4><p>Create additional assets for the chunks.</p><h4 id=record><a class=anchor href=#record>&rarr;</a><code>record(compilation, records)</code></h4><p>Store info about the compilation to the records</p><h4 id=optimize-chunk-assets-async><a class=anchor href=#optimize-chunk-assets-async>&rarr;</a><code>optimize-chunk-assets(chunks: Chunk[])</code> async</h4><p>Optimize the assets for the chunks.</p><p>The assets are stored in <code><span class=keyword>this</span>.assets</code>, but not all of them are chunk assets. A <code>Chunk</code> has a property <code>files</code> which points to all files created by this chunk. The additional chunk assets are stored in <code><span class=keyword>this</span>.additionalChunkAssets</code>.</p><p>Here’s an example that simply adds a banner to each chunk.</p><pre><code>compilation.plugin(<span class=string>"optimize-chunk-assets"</span>, <span class=function><span class=keyword>function</span><span class=params>(chunks, callback)</span> {</span>
    chunks.forEach(<span class=function><span class=keyword>function</span><span class=params>(chunk)</span> {</span>
        chunk.files.forEach(<span class=function><span class=keyword>function</span><span class=params>(file)</span> {</span>
            compilation.assets[file] = <span class=keyword>new</span> ConcatSource(<span class=string>"\/**Sweet Banner**\/"</span>, <span class=string>"\n"</span>, compilation.assets[file]);
        });
    });
    callback();
});</code></pre><h4 id=after-optimize-chunk-assets><a class=anchor href=#after-optimize-chunk-assets>&rarr;</a><code>after-optimize-chunk-assets(chunks: Chunk[])</code></h4><p>The chunk assets have been optimized. Here’s an example plugin from <a href=https://github.com/boopathi>@boopathi</a> that outputs exactly what went into each chunk.</p><pre><code><span class=keyword>var</span> PrintChunksPlugin = <span class=function><span class=keyword>function</span><span class=params>()</span> {</span>};
PrintChunksPlugin.prototype.apply = <span class=function><span class=keyword>function</span><span class=params>(compiler)</span> {</span>
    compiler.plugin(<span class=string>'compilation'</span>, <span class=function><span class=keyword>function</span><span class=params>(compilation, params)</span> {</span>
        compilation.plugin(<span class=string>'after-optimize-chunk-assets'</span>, <span class=function><span class=keyword>function</span><span class=params>(chunks)</span> {</span>
            console.log(chunks.map(<span class=function><span class=keyword>function</span><span class=params>(c)</span> {</span>
                <span class=keyword>return</span> {
                    id: c.id,
                    name: c.name,
                    includes: c.modules.map(<span class=function><span class=keyword>function</span><span class=params>(m)</span> {</span>
                        <span class=keyword>return</span> m.request;
                    })
                };
            }));
        });
    });
};</code></pre><h4 id=optimize-assets-async><a class=anchor href=#optimize-assets-async>&rarr;</a><code>optimize-assets(assets: Object{name: Source})</code> async</h4><p>Optimize all assets.</p><p>The assets are stored in <code><span class=keyword>this</span>.assets</code>.</p><h4 id=after-optimize-assets><a class=anchor href=#after-optimize-assets>&rarr;</a><code>after-optimize-assets(assets: Object{name: Source})</code></h4><p>The assets has been optimized.</p><h4 id=build-module><a class=anchor href=#build-module>&rarr;</a><code>build-module(module)</code></h4><p>Before a module build has started.</p><pre><code>compilation.plugin(<span class=string>'build-module'</span>, <span class=function><span class=keyword>function</span><span class=params>(module)</span>{</span>
    console.log(<span class=string>'build module'</span>);
    console.log(module);
});</code></pre><h4 id=succeed-module><a class=anchor href=#succeed-module>&rarr;</a><code>succeed-module(module)</code></h4><p>A module has been built successfully.</p><pre><code>compilation.plugin(<span class=string>'succeed-module'</span>, <span class=function><span class=keyword>function</span><span class=params>(module)</span>{</span>
    console.log(<span class=string>'succeed module'</span>);
    console.log(module);
});</code></pre><h4 id=failed-module><a class=anchor href=#failed-module>&rarr;</a><code>failed-module(module)</code></h4><p>The module build has failed.</p><pre><code>compilation.plugin(<span class=string>'failed-module'</span>, <span class=function><span class=keyword>function</span><span class=params>(module)</span>{</span>
    console.log(<span class=string>'failed module'</span>);
    console.log(module);
});</code></pre><h4 id=module-asset><a class=anchor href=#module-asset>&rarr;</a><code>module-asset(module, filename)</code></h4><p>An asset from a module was added to the compilation.</p><h4 id=chunk-asset><a class=anchor href=#chunk-asset>&rarr;</a><code>chunk-asset(chunk, filename)</code></h4><p>An asset from a chunk was added to the compilation.</p><h1 id=the-maintemplate-instance><a class=anchor href=#the-maintemplate-instance>&rarr;</a>The <code>MainTemplate</code> instance</h1><h4 id=startup><a class=anchor href=#startup>&rarr;</a><code>startup(source, module, hash)</code></h4><pre><code>    compilation.mainTemplate.plugin(<span class=string>'startup'</span>, <span class=function><span class=keyword>function</span><span class=params>(source, module, hash)</span> {</span>
      <span class=keyword>if</span> (!module.chunks.length &amp;&amp; source.indexOf(<span class=string>'__ReactStyle__'</span>) === -<span class=number>1</span>) {
        <span class=keyword>var</span> originName = module.origins &amp;&amp; module.origins.length ? module.origins[<span class=number>0</span>].name : <span class=string>'main'</span>;
        <span class=keyword>return</span> [<span class=string>'if (typeof window !== "undefined") {'</span>,
            <span class=string>'  window.__ReactStyle__ = '</span> + JSON.stringify(classNames[originName]) + <span class=string>';'</span>,
            <span class=string>'}'</span>
          ].join(<span class=string>'\n'</span>) + source;
      }
      <span class=keyword>return</span> source;
    });</code></pre><h1 id=the-parser-instance><a class=anchor href=#the-parser-instance>&rarr;</a>The <code>Parser</code> instance (<code>compiler.parser</code>)</h1><p>The parser instance takes a String and callback and will return an expression when there’s a match.</p><pre><code>compiler.parser.plugin(<span class=string>"var rewire"</span>, <span class=function><span class=keyword>function</span> <span class=params>(expr)</span> {</span>
    <span class=comment>//if you original module has 'var rewire'</span>
    <span class=comment>//you now have a handle on the expresssion object   </span>
    <span class=keyword>return</span> <span class=literal>true</span>;
});</code></pre><h4 id=program-bailing><a class=anchor href=#program-bailing>&rarr;</a><code>program(ast)</code> bailing</h4><p>General purpose plugin interface for the AST of a code fragment.</p><h4 id=statement-bailing><a class=anchor href=#statement-bailing>&rarr;</a><code>statement(statement: Statement)</code> bailing</h4><p>General purpose plugin interface for the statements of the code fragment.</p><h4 id=call-identifier-bailing><a class=anchor href=#call-identifier-bailing>&rarr;</a><code>call &lt;identifier&gt;(expr: Expression)</code> bailing</h4><p><code>abc(<span class=number>1</span>)</code> =&gt; <code>call abc</code></p><p><code>a.b.c(<span class=number>1</span>)</code> =&gt; <code>call a.b.c</code></p><h4 id=expression-identifier-bailing><a class=anchor href=#expression-identifier-bailing>&rarr;</a><code>expression &lt;identifier&gt;(expr: Expression)</code> bailing</h4><p><code>abc</code> =&gt; <code>expression abc</code></p><p><code>a.b.c</code> =&gt; <code>expression a.b.c</code></p><h4 id=expression-bailing><a class=anchor href=#expression-bailing>&rarr;</a><code>expression ?:(expr: Expression)</code> bailing</h4><p><code>(abc ? <span class=number>1</span> : <span class=number>2</span>)</code> =&gt; <code>expression ?!</code></p><p>Return a boolean value to omit parsing of the wrong path.</p><h4 id=typeof-identifier-bailing><a class=anchor href=#typeof-identifier-bailing>&rarr;</a><code><span class=keyword>typeof</span> &lt;identifier&gt;(expr: Expression)</code> bailing</h4><p><code><span class=keyword>typeof</span> a.b.c</code> =&gt; <code><span class=keyword>typeof</span> a.b.c</code></p><h4 id=statement-if-bailing><a class=anchor href=#statement-if-bailing>&rarr;</a><code>statement <span class=keyword>if</span>(statement: Statement)</code> bailing</h4><p><code><span class=keyword>if</span>(abc) {}</code> =&gt; <code>statement <span class=keyword>if</span></code></p><p>Return a boolean value to omit parsing of the wrong path.</p><h4 id=label-labelname-bailing><a class=anchor href=#label-labelname-bailing>&rarr;</a><code>label &lt;labelname&gt;(statement: Statement)</code> bailing</h4><p><code>xyz: abc</code> =&gt; <code>label xyz</code></p><h4 id=var-name-bailing><a class=anchor href=#var-name-bailing>&rarr;</a><code><span class=keyword>var</span> &lt;name&gt;(statement: Statement)</code> bailing</h4><p><code><span class=keyword>var</span> abc, def</code> =&gt; <code><span class=keyword>var</span> abc</code> + <code><span class=keyword>var</span> def</code></p><p>Return <code><span class=literal>false</span></code> to not add the variable to the known definitions.</p><h4 id=evaluate-expression-type-bailing><a class=anchor href=#evaluate-expression-type-bailing>&rarr;</a><code>evaluate &lt;expression type&gt;(expr: Expression)</code> bailing</h4><p>Evaluate an expression.</p><h4 id=evaluate-typeof-identifier-bailing><a class=anchor href=#evaluate-typeof-identifier-bailing>&rarr;</a><code>evaluate <span class=keyword>typeof</span> &lt;identifier&gt;(expr: Expression)</code> bailing</h4><p>Evaluate the type of an identifier.</p><h4 id=evaluate-identifier-identifier-bailing><a class=anchor href=#evaluate-identifier-identifier-bailing>&rarr;</a><code>evaluate Identifier &lt;identifier&gt;(expr: Expression)</code> bailing</h4><p>Evaluate a identifier that is a free var.</p><h4 id=evaluate-defined-identifier-identifier-bailing><a class=anchor href=#evaluate-defined-identifier-identifier-bailing>&rarr;</a><code>evaluate defined Identifier &lt;identifier&gt;(expr: Expression)</code> bailing</h4><p>Evaluate a identifier that is a defined var.</p><h4 id=evaluate-callexpression-property-bailing><a class=anchor href=#evaluate-callexpression-property-bailing>&rarr;</a><code>evaluate CallExpression .<span class=xml><span class=tag>&lt;<span class=title>property</span>&gt;</span>(expr: Expression)</span></code> bailing</h4><p>Evaluate a call to a member function of a successfully evaluated expression.</p><h1 id=the-normalmodulefactory><a class=anchor href=#the-normalmodulefactory>&rarr;</a>The <code>NormalModuleFactory</code></h1><h4 id=before-resolve-async-waterfall><a class=anchor href=#before-resolve-async-waterfall>&rarr;</a><code>before-resolve(data)</code> async waterfall</h4><p>Before the factory starts resolving. The <code>data</code> object has these properties:</p><ul><li><code>context</code> The absolute path of the directory for resolving.</li><li><code>request</code> The request of the expression.</li></ul><p>Plugins are allowed to modify the object or to pass a new similar object to the callback.</p><h4 id=after-resolve-async-waterfall><a class=anchor href=#after-resolve-async-waterfall>&rarr;</a><code>after-resolve(data)</code> async waterfall</h4><p>After the factory has resolved the request. The <code>data</code> object has these properties:</p><ul><li><code>request</code> The resolved request. It acts as an identifier for the NormalModule.</li><li><code>userRequest</code> The request the user entered. It’s resolved, but does not contain pre or post loaders.</li><li><code>rawRequest</code> The unresolved request.</li><li><code>loaders</code> A array of resolved loaders. This is passed to the NormalModule and they will be executed.</li><li><code>resource</code> The resource. It will be loaded by the NormalModule.</li><li><code>parser</code> The parser that will be used by the NormalModule.</li></ul><h1 id=the-contextmodulefactory><a class=anchor href=#the-contextmodulefactory>&rarr;</a>The <code>ContextModuleFactory</code></h1><h4 id=before-resolve-async-waterfall><a class=anchor href=#before-resolve-async-waterfall>&rarr;</a><code>before-resolve(data)</code> async waterfall</h4><h4 id=after-resolve-async-waterfall><a class=anchor href=#after-resolve-async-waterfall>&rarr;</a><code>after-resolve(data)</code> async waterfall</h4><h4 id=alternatives-async-waterfall><a class=anchor href=#alternatives-async-waterfall>&rarr;</a><code>alternatives(options: Array)</code> async waterfall</h4><h1 id=resolvers><a class=anchor href=#resolvers>&rarr;</a>Resolvers</h1><ul><li><code>compiler.resolvers.normal</code> Resolver for a normal module</li><li><code>compiler.resolvers.context</code> Resolver for a context module</li><li><code>compiler.resolvers.loader</code> Resolver for a loader</li></ul><p>Any plugin should use <code><span class=keyword>this</span>.fileSystem</code> as fileSystem, as it’s cached. It only has async named functions, but they may behave sync, if the user uses a sync file system implementation (i. e. in enhanced-require).</p><p>To join paths any plugin should use <code><span class=keyword>this</span>.join</code>. It normalizes the paths. There is a <code><span class=keyword>this</span>.normalize</code> too.</p><p>A bailing async forEach implementation is available on <code><span class=keyword>this</span>.forEachBail(array, iterator, callback)</code>.</p><p>To pass the request to other resolving plugins, use the <code><span class=keyword>this</span>.doResolve(types: String|String[], request: Request, callback)</code> method. <code>types</code> are multiple possible request types that are tested in order of preference.</p><pre><code>interface Request {
    path: String <span class=comment>// The current directory of the request</span>
    request: String <span class=comment>// The current request string</span>
    query: String <span class=comment>// The query string of the request, if any</span>
    module: boolean <span class=comment>// The request begins with a module</span>
    directory: boolean <span class=comment>// The request points to a directory</span>
    file: boolean <span class=comment>// The request points to a file</span>
    resolved: boolean <span class=comment>// The request is resolved/done</span>
    <span class=comment>// undefined means false for boolean fields</span>
}

<span class=comment>// Examples</span>
<span class=comment>// from /home/user/project/file.js: require("../test?charset=ascii")</span>
{
    path: <span class=string>"/home/user/project"</span>,
    request: <span class=string>"../test"</span>,
    query: <span class=string>"?charset=ascii"</span>
}
<span class=comment>// from /home/user/project/file.js: require("test/test/")</span>
{
    path: <span class=string>"/home/user/project"</span>,
    request: <span class=string>"test/test/"</span>,
    module: <span class=literal>true</span>,
    directory: <span class=literal>true</span>
}</code></pre><h4 id=resolve><a class=anchor href=#resolve>&rarr;</a><code>resolve(context: String, request: String)</code></h4><p>Before the resolving process starts.</p><h4 id=resolve-step><a class=anchor href=#resolve-step>&rarr;</a><code>resolve-step(types: String[], request: Request)</code></h4><p>Before a single step in the resolving process starts.</p><h4 id=module-async-waterfall><a class=anchor href=#module-async-waterfall>&rarr;</a><code>module(request: Request)</code> async waterfall</h4><p>A module request is found and should be resolved.</p><h4 id=directory-async-waterfall><a class=anchor href=#directory-async-waterfall>&rarr;</a><code>directory(request: Request)</code> async waterfall</h4><p>A directory request is found and should be resolved.</p><h4 id=file-async-waterfall><a class=anchor href=#file-async-waterfall>&rarr;</a><code>file(request: Request)</code> async waterfall</h4><p>A file request is found and should be resolved.</p><h4 id=the-plugins-may-offer-more-extensions-points><a class=anchor href=#the-plugins-may-offer-more-extensions-points>&rarr;</a>The plugins may offer more extensions points</h4><p>Here is a list what the default plugins in webpack offer. They are all <code>(request: Request)</code> async waterfall.</p><p>The process for normal modules and contexts is <code>module -&gt; module-module -&gt; directory -&gt; file</code>.</p><p>The process for loaders is <code>module -&gt; module-loader-module -&gt; module-module -&gt; directory -&gt; file</code>.</p><h4 id=module-module><a class=anchor href=#module-module>&rarr;</a><code>module-module</code></h4><p>A module should be looked up in a specified directory. <code>path</code> contains the directory.</p><h4 id=module-loader-module><a class=anchor href=#module-loader-module>&rarr;</a><code>module-loader-module</code> (only for loaders)</h4><p>Used before module templates are applied to the module name. The process continues with <code>module-module</code>.</p></div></div><div class=row><div class=col-md-12><div class=pull-right><a href=https://github.com/webpack/docs/wiki/plugins/_edit class=wikieditlink>Edit this page</a></div></div></div><div class=row><div class=col-md-12><div id=disqus_thread></div></div></div></div></div></div><a href=https://github.com/webpack/webpack><img style="position: absolute; top: 0; left: 0; border: 0" src=https://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png alt="Fork me on GitHub"></a>