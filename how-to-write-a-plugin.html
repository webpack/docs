<!DOCTYPE html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=""><meta name=author content=""><link rel=icon type=image/png href="/assets/favicon.png"><link rel=stylesheet href=https://cdn.jsdelivr.net/docsearch.js/2.1.8/docsearch.min.css integrity=sha384-/h/CVRynn/dNPld+6a4vrwfa+2rmLNF4BIustqdtI2P8kqtFvUOsgA+TXqp+6F04 crossorigin=anonymous><link rel=stylesheet href="css/doc.css"><title>how to write a plugin</title><body><script src=https://cdn.jsdelivr.net/docsearch.js/2.1.8/docsearch.min.js integrity=sha384-u5+p4sI6IAzw0829Aqivzf5sJed6yKCHDofUkWCK5Zs6w/DQr9JleVL3lrVLgufR crossorigin=anonymous async></script><script src=js/doc.js charset=utf-8 async></script><div class=container><div class=row><div class="col-md-3 nav"><div class=logo><ul class=cube-inner><li class=front></li><li class=back></li><li class=right></li><li class=left></li><li class=top></li><li class=bottom></li></ul><ul class=cube><li class=front></li><li class=back></li><li class=right></li><li class=left></li><li class=top></li><li class=bottom></li><li class=floor></li></ul></div><div class=name>webpack</div><div class=tagline>MODULE BUNDLER</div><div class=sidebar><input id=docsearch><ul><li><a href=.>Home</a></li></ul><ul><li>Getting Started<ul><li><a href=motivation.html>Motivation</a></li><li><a href=what-is-webpack.html>What is webpack?</a></li><li><a href=installation.html>Installation</a></li><li><a href=usage.html>Usage</a></li><li>Require Modules</li><li>Vendor Modules</li><li><a href=using-loaders.html>Using Loaders</a></li><li><a href=using-plugins.html>Using Plugins</a></li><li><a href=dev-tools.html>Dev Tools</a></li><li><a href=troubleshooting.html>Troubleshooting</a></li></ul></li><li>Tutorials and examples<ul><li><a href="http://webpack.github.io/docs/tutorials/getting-started/">Getting started</a></li><li><a href=list-of-tutorials.html>List of tutorials</a></li><li><a href=examples.html>examples</a></li></ul></li><li>Guides<ul><li><a href=commonjs.html>CommonJs</a></li><li><a href=amd.html>AMD</a></li><li><a href=webpack-for-browserify-users.html>webpack for browserify users</a></li><li><a href=code-splitting.html>Code Splitting</a></li><li><a href=stylesheets.html>Stylesheets</a></li><li><a href=optimization.html>Optimization</a></li><li><a href=long-term-caching.html>Long-term Caching</a></li><li><a href=how-to-write-a-loader.html>How to write a loader</a></li><li><a href=how-to-write-a-plugin.html>How to write a plugin</a></li><li><a href=multiple-entry-points.html>Multiple entry points</a></li><li><a href=library-and-externals.html>Library and externals</a></li><li><a href=shimming-modules.html>Shimming modules</a></li><li><a href=testing.html>Testing</a></li><li><a href=build-performance.html>Build performance</a></li><li><a href=hot-module-replacement-with-webpack.html>Hot Module Replacement with webpack</a></li><li><a href=comparison.html>Comparison</a></li></ul></li><li>webpack with<ul><li><a href=usage-with-grunt.html>grunt</a></li><li><a href=usage-with-gulp.html>gulp</a></li><li><a href=usage-with-bower.html>bower</a></li><li><a href=usage-with-karma.html>karma</a></li></ul></li><li>Lists<ul><li><a href=loader-conventions.html>loader conventions</a></li><li><a href=list-of-loaders.html>List of loaders</a></li><li><a href=list-of-plugins.html>List of plugins</a></li><li><a href=list-of-tutorials.html>List of tutorials</a></li><li><a href=list-of-hints.html>List of hints</a></li></ul></li><li>API<ul><li><a href=configuration.html>Configuration</a></li><li><a href=cli.html>CLI</a></li><li><a href=node.js-api.html>Node.js API</a></li><li><a href=api-in-modules.html>API in modules</a></li><li><a href=loaders.html>Loaders</a></li><li><a href=plugins.html>Plugins</a></li><li><a href=context.html>Context</a></li><li><a href=resolving.html>Resolving</a></li><li><a href=hot-module-replacement.html>Hot Module Replacement</a></li><li>Dev Tools<ul><li><a href=webpack-dev-server.html>webpack-dev-server</a></li><li><a href=webpack-dev-middleware.html>webpack-dev-middleware</a></li></ul></li></ul></li><li>Development<ul><li><a href=changelog.html>Changelog</a></li><li><a href=roadmap.html>Roadmap</a></li><li><a href=ideas.html>Ideas</a></li><li>Contributing</li></ul></li></ul></div></div><div class=col-md-9><!--<div class="announcement">
						<div class="announcement-inner">
							<em>2014-07-04</em> Help to improve webpack by filling out <a href="https://docs.google.com/forms/d/101ZcujnVL8l575T6VRl62SfrVj5FZC1IzwMH1258GVc/viewform">this little survey</a>. Thanks!<br>
							<em>2015-03-04</em> You can now comment doc pages (on the bottom of the page). Free feel to add comments about missing/unclear stuff or fix stuff that other people find unclear. You can use the Edit button on the top right corner.
						</div>
					</div>--><div class=pull-right><a href=https://github.com/webpack/docs/wiki/how-to-write-a-plugin/_edit class=wikieditlink>Edit</a></div><div class=row><div class="col-md-12 page-header"><h1 id=wikititle>how to write a plugin</h1></div></div><div class=row><div id=wiki class=col-md-12><div class=contents><ul><li><a href=#compiler-and-compilation>Compiler and Compilation</a></li><li><a href=#basic-plugin-architecture>Basic plugin architecture</a></li><li><a href=#accessing-the-compilation>Accessing the compilation</a></li><li><a href=#async-compilation-plugins>Async compilation plugins</a></li><li><a href=#a-simple-example>A simple example</a></li><li><a href=#useful-plugin-patterns>Useful Plugin Patterns</a><ul><li><a href=#exploring-assets-chunks-modules-and-dependencies>Exploring assets, chunks, modules, and dependencies</a></li><li><a href=#monitoring-the-watch-graph>Monitoring the watch graph</a></li><li><a href=#changed-chunks>Changed chunks</a></li></ul></li></ul></div><p>Plugins expose the full potential of the Webpack engine to third-party developers. Using staged build callbacks, developers can introduce their own behaviors into the Webpack build process. Building plugins is a bit more advanced than building loaders, because you’ll need to understand some of the Webpack low-level internals to hook into them. Be prepared to read some source code!</p><h2 id=compiler-and-compilation><a class=anchor href=#compiler-and-compilation>&rarr;</a>Compiler and Compilation</h2><p>Among the two most important resources while developing plugins are the <code>compiler</code> and <code>compilation</code> objects. Understanding their roles is an important first step in extending the Webpack engine.</p><ul><li><p>The <code>compiler</code> object represents the fully configured Webpack environment. This object is built once upon starting Webpack, and is configured with all operational settings including options, loaders, and plugins. When applying a plugin to the Webpack environment, the plugin will receive a reference to this compiler. Use the compiler to access the main Webpack environment.</p></li><li><p>A <code>compilation</code> object represents a single build of versioned assets. While running Webpack development middleware, a new compilation will be created each time a file change is detected, thus generating a new set of compiled assets. A compilation surfaces information about the present state of module resources, compiled assets, changed files, and watched dependencies. The compilation also provides many callback points at which a plugin may choose to perform custom actions.</p></li></ul><p>These two components are an integral part of any Webpack plugin (especially a <code>compilation</code>), so developers will benefit by familiarizing themselves with these source files:</p><ul><li><a href=https://github.com/webpack/webpack/blob/master/lib/Compiler.js>Compiler Source</a></li><li><a href=https://github.com/webpack/webpack/blob/master/lib/Compilation.js>Compilation Source</a></li></ul><h2 id=basic-plugin-architecture><a class=anchor href=#basic-plugin-architecture>&rarr;</a>Basic plugin architecture</h2><p>Plugins are instanceable objects with an <code>apply</code> method on their prototype. This <code>apply</code> method is called once by the Webpack compiler while installing the plugin. The <code>apply</code> method is given a reference to the underlying Webpack compiler, which grants access to compiler callbacks. A simple plugin is structured as follows:</p><pre><code><span class=function><span class=keyword>function</span> <span class=title>HelloWorldPlugin</span><span class=params>(options)</span> {</span>
  <span class=comment>// Setup the plugin instance with options...</span>
}

HelloWorldPlugin.prototype.apply = <span class=function><span class=keyword>function</span><span class=params>(compiler)</span> {</span>
  compiler.plugin(<span class=string>'done'</span>, <span class=function><span class=keyword>function</span><span class=params>()</span> {</span>
    console.log(<span class=string>'Hello World!'</span>); 
  });
};

module.exports = HelloWorldPlugin;</code></pre><p>Then to install the plugin, just include an instance in your Webpack config <code>plugins</code> array:</p><pre><code><span class=keyword>var</span> HelloWorldPlugin = require(<span class=string>'hello-world'</span>);

<span class=keyword>var</span> webpackConfig = {
  <span class=comment>// ... config settings here ...</span>
  plugins: [
    <span class=keyword>new</span> HelloWorldPlugin({options: <span class=literal>true</span>})
  ]
};</code></pre><h2 id=accessing-the-compilation><a class=anchor href=#accessing-the-compilation>&rarr;</a>Accessing the compilation</h2><p>Using the compiler object, you may bind callbacks that provide a reference to each new compilation. These compilations provide callbacks for hooking into numerous steps within the build process.</p><pre><code><span class=function><span class=keyword>function</span> <span class=title>HelloCompilationPlugin</span><span class=params>(options)</span> {</span>}

HelloCompilationPlugin.prototype.apply = <span class=function><span class=keyword>function</span><span class=params>(compiler)</span> {</span>

  <span class=comment>// Setup callback for accessing a compilation:</span>
  compiler.plugin(<span class=string>"compilation"</span>, <span class=function><span class=keyword>function</span><span class=params>(compilation)</span> {</span>

    <span class=comment>// Now setup callbacks for accessing compilation steps:</span>
    compilation.plugin(<span class=string>"optimize"</span>, <span class=function><span class=keyword>function</span><span class=params>()</span> {</span>
      console.log(<span class=string>"Assets are being optimized."</span>);
    });
  });
};

module.exports = HelloCompilationPlugin;</code></pre><p>For more information on what callbacks are available on the <code>compiler</code>, <code>compilation</code>, and other important objects, see the <a href=plugins.html>plugins API</a> doc.</p><h2 id=async-compilation-plugins><a class=anchor href=#async-compilation-plugins>&rarr;</a>Async compilation plugins</h2><p>Some compilation plugin steps are asynchronous, and pass a callback function that <em>must</em> be invoked when your plugin is finished running.</p><pre><code><span class=function><span class=keyword>function</span> <span class=title>HelloAsyncPlugin</span><span class=params>(options)</span> {</span>}

HelloAsyncPlugin.prototype.apply = <span class=function><span class=keyword>function</span><span class=params>(compiler)</span> {</span>
  compiler.plugin(<span class=string>"emit"</span>, <span class=function><span class=keyword>function</span><span class=params>(compilation, callback)</span> {</span>

    <span class=comment>// Do something async...</span>
    setTimeout(<span class=function><span class=keyword>function</span><span class=params>()</span> {</span>
      console.log(<span class=string>"Done with async work..."</span>);
      callback();
    }, <span class=number>1000</span>);

  });
};

module.exports = HelloAsyncPlugin;</code></pre><h2 id=a-simple-example><a class=anchor href=#a-simple-example>&rarr;</a>A simple example</h2><p>Once we can latch onto the Webpack compiler and each individual compilations, the possibilities become endless for what we can do with the engine itself. We can reformat existing files, create derivative files, or fabricate entirely new assets.</p><p>Let’s write a simple example plugin that generates a new build file called <code>filelist.md</code>; the contents of which will list all of the asset files in our build. This plugin might look something like this:</p><pre><code><span class=function><span class=keyword>function</span> <span class=title>FileListPlugin</span><span class=params>(options)</span> {</span>}

FileListPlugin.prototype.apply = <span class=function><span class=keyword>function</span><span class=params>(compiler)</span> {</span>
  compiler.plugin(<span class=string>'emit'</span>, <span class=function><span class=keyword>function</span><span class=params>(compilation, callback)</span> {</span>
    <span class=comment>// Create a header string for the generated file:</span>
    <span class=keyword>var</span> filelist = <span class=string>'In this build:\n\n'</span>;

    <span class=comment>// Loop through all compiled assets,</span>
    <span class=comment>// adding a new line item for each filename.</span>
    <span class=keyword>for</span> (<span class=keyword>var</span> filename <span class=keyword>in</span> compilation.assets) {
      filelist += (<span class=string>'- '</span>+ filename +<span class=string>'\n'</span>);
    }

    <span class=comment>// Insert this list into the Webpack build as a new file asset:</span>
    compilation.assets[<span class=string>'filelist.md'</span>] = {
      source: <span class=function><span class=keyword>function</span><span class=params>()</span> {</span>
        <span class=keyword>return</span> filelist;
      },
      size: <span class=function><span class=keyword>function</span><span class=params>()</span> {</span>
        <span class=keyword>return</span> filelist.length;
      }
    };

    callback();
  });
};

module.exports = FileListPlugin;</code></pre><h2 id=useful-plugin-patterns><a class=anchor href=#useful-plugin-patterns>&rarr;</a>Useful Plugin Patterns</h2><p>Plugins grant unlimited opportunity to perform customizations within the Webpack build system. This allows you to create custom asset types, perform unique build modifications, or even enhance the Webpack runtime while using middleware. The following are some features of Webpack that become very useful while writing plugins.</p><h3 id=exploring-assets-chunks-modules-and-dependencies><a class=anchor href=#exploring-assets-chunks-modules-and-dependencies>&rarr;</a>Exploring assets, chunks, modules, and dependencies</h3><p>After a compilation is sealed, all structures within the compilation may be traversed.</p><pre><code><span class=function><span class=keyword>function</span> <span class=title>MyPlugin</span><span class=params>()</span> {</span>}

MyPlugin.prototype.apply = <span class=function><span class=keyword>function</span><span class=params>(compiler)</span> {</span>
  compiler.plugin(<span class=string>'emit'</span>, <span class=function><span class=keyword>function</span><span class=params>(compilation, callback)</span> {</span>

    <span class=comment>// Explore each chunk (build output):</span>
    compilation.chunks.forEach(<span class=function><span class=keyword>function</span><span class=params>(chunk)</span> {</span>
      <span class=comment>// Explore each module within the chunk (built inputs):</span>
      chunk.modules.forEach(<span class=function><span class=keyword>function</span><span class=params>(module)</span> {</span>
        <span class=comment>// Explore each source file path that was included into the module:</span>
        module.fileDependencies.forEach(<span class=function><span class=keyword>function</span><span class=params>(filepath)</span> {</span>
          <span class=comment>// we've learned a lot about the source structure now...</span>
        });
      });

      <span class=comment>// Explore each asset filename generated by the chunk:</span>
      chunk.files.forEach(<span class=function><span class=keyword>function</span><span class=params>(filename)</span> {</span>
        <span class=comment>// Get the asset source for each file generated by the chunk:</span>
        <span class=keyword>var</span> source = compilation.assets[filename].source();
      });
    });

    callback();
  });
};

module.exports = MyPlugin;</code></pre><ul><li><p><code>compilation.modules</code>: An array of modules (built inputs) in the compilation. Each module manages the build of a raw file from your source library.</p></li><li><p><code>module.fileDependencies</code>: An array of source file paths included into a module. This includes the source JavaScript file itself (ex: <code>index.js</code>), and all dependency asset files (stylesheets, images, etc) that it has required. Reviewing dependencies is useful for seeing what source files belong to a module.</p></li><li><p><code>compilation.chunks</code>: An array of chunks (build outputs) in the compilation. Each chunk manages the composition of a final rendered assets.</p></li><li><p><code>chunk.modules</code>: An array of modules that are included into a chunk. By extension, you may look through each module’s dependencies to see what raw source files fed into a chunk.</p></li><li><p><code>chunk.files</code>: An array of output filenames generated by the chunk. You may access these asset sources from the <code>compilation.assets</code> table.</p></li></ul><h3 id=monitoring-the-watch-graph><a class=anchor href=#monitoring-the-watch-graph>&rarr;</a>Monitoring the watch graph</h3><p>While running Webpack middleware, each compilation includes a <code>fileDependencies</code> array (what files are being watched) and a <code>fileTimestamps</code> hash that maps watched file paths to a timestamp. These are extremely useful for detecting what files have changed within the compilation:</p><pre><code><span class=function><span class=keyword>function</span> <span class=title>MyPlugin</span><span class=params>()</span> {</span>
  <span class=keyword>this</span>.startTime = Date.now();
  <span class=keyword>this</span>.prevTimestamps = {};
}

MyPlugin.prototype.apply = <span class=function><span class=keyword>function</span><span class=params>(compiler)</span> {</span>
  compiler.plugin(<span class=string>'emit'</span>, <span class=function><span class=keyword>function</span><span class=params>(compilation, callback)</span> {</span>

    <span class=keyword>var</span> changedFiles = Object.keys(compilation.fileTimestamps).filter(<span class=function><span class=keyword>function</span><span class=params>(watchfile)</span> {</span>
      <span class=keyword>return</span> (<span class=keyword>this</span>.prevTimestamps[watchfile] || <span class=keyword>this</span>.startTime) &lt; (compilation.fileTimestamps[watchfile] || <span class=literal>Infinity</span>);
    }.bind(<span class=keyword>this</span>));

    <span class=keyword>this</span>.prevTimestamps = compilation.fileTimestamps;
    callback();
  }.bind(<span class=keyword>this</span>));
};

module.exports = MyPlugin;</code></pre><p>You may also feed new file paths into the watch graph to receive compilation triggers when those files change. Simply push valid filepaths into the <code>compilation.fileDependencies</code> array to add them to the watch. Note: the <code>fileDependencies</code> array is rebuilt in each compilation, so your plugin must push its own watched dependencies into each compilation to keep them under watch.</p><h3 id=changed-chunks><a class=anchor href=#changed-chunks>&rarr;</a>Changed chunks</h3><p>Similar to the watch graph, it’s fairly simple to monitor changed chunks (or modules, for that matter) within a compilation by tracking their hashes.</p><pre><code><span class=function><span class=keyword>function</span> <span class=title>MyPlugin</span><span class=params>()</span> {</span>
  <span class=keyword>this</span>.chunkVersions = {};
}

MyPlugin.prototype.apply = <span class=function><span class=keyword>function</span><span class=params>(compiler)</span> {</span>
  compiler.plugin(<span class=string>'emit'</span>, <span class=function><span class=keyword>function</span><span class=params>(compilation, callback)</span> {</span>

    <span class=keyword>var</span> changedChunks = compilation.chunks.filter(<span class=function><span class=keyword>function</span><span class=params>(chunk)</span> {</span>
      <span class=keyword>var</span> oldVersion = <span class=keyword>this</span>.chunkVersions[chunk.name];
      <span class=keyword>this</span>.chunkVersions[chunk.name] = chunk.hash;
      <span class=keyword>return</span> chunk.hash !== oldVersion;
    }.bind(<span class=keyword>this</span>));

    callback();
  }.bind(<span class=keyword>this</span>));
};

module.exports = MyPlugin;</code></pre></div></div><div class=row><div class=col-md-12><div class=pull-right><a href=https://github.com/webpack/docs/wiki/how-to-write-a-plugin/_edit class=wikieditlink>Edit this page</a></div></div></div><div class=row><div class=col-md-12><div id=disqus_thread></div></div></div></div></div></div><a href=https://github.com/webpack/webpack><img style="position: absolute; top: 0; left: 0; border: 0" src=https://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png alt="Fork me on GitHub"></a>